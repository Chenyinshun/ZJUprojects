# -*- coding: utf-8 -*-
# 化学方程式配平程序
# 主要功能：通过GUI界面输入化学方程式，使用sympy库进行配平计算

# Form implementation generated from reading ui file '2.1.0.ui'
# 注意：此文件由PyQt5 UI文件自动生成，手动修改可能会被覆盖
# Created by: PyQt5 UI code generator 5.15.4
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# 导入必要的库
from PyQt5.QtWidgets import *  # PyQt5 GUI组件
from PyQt5.QtGui import QIntValidator, QDoubleValidator, QRegExpValidator  # 输入验证器
from PyQt5.QtCore import QRegExp  # 正则表达式
from PyQt5 import QtCore  # Qt核心模块
import sys  # 系统相关操作
import sympy as sp  # 符号计算库，用于求解方程
import time  # 时间相关
import sympy.simplify.simplify  # sympy简化模块
import math  # 数学运算

# 全局变量定义
l1 = []  # 存储反应物列表
l2 = []  # 存储生成物列表

# 定义化学方程式中可能用到的系数符号（最多支持20个物质）
# 这些符号将被用于构建方程组
symbols_dict = {
    'a': sp.Symbol('a'),  # 第1个系数
    'b': sp.Symbol('b'),  # 第2个系数
    'c': sp.Symbol('c'),  # 第3个系数
    'd': sp.Symbol('d'),  # 第4个系数
    'e': sp.Symbol('e'),  # 第5个系数
    'f': sp.Symbol('f'),  # 第6个系数
    'g': sp.Symbol('g'),  # 第7个系数
    'h': sp.Symbol('h'),  # 第8个系数
    'i': sp.Symbol('i'),  # 第9个系数
    'j': sp.Symbol('j'),  # 第10个系数
    'k': sp.Symbol('k'),  # 第11个系数
    'l': sp.Symbol('l'),  # 第12个系数
    'm': sp.Symbol('m'),  # 第13个系数
    'n': sp.Symbol('n'),  # 第14个系数
    'o': sp.Symbol('o'),  # 第15个系数
    'p': sp.Symbol('p'),  # 第16个系数
    'q': sp.Symbol('q'),  # 第17个系数
    'r': sp.Symbol('r'),  # 第18个系数
    's': sp.Symbol('s'),  # 第19个系数
    't': sp.Symbol('t')  # 第20个系数
}

# 符号列表，按顺序排列
ert = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't']


# 原有函数定义保持不变...
def fangfa(HXS):
    """
    分析化学式中的括号匹配情况

    参数:
        HXS (str): 化学式字符串

    返回:
        dict: 包含括号位置信息的字典

    异常:
        Warning: 当括号不匹配时抛出
    """
    length = len(HXS)  # 获取字符串长度
    nem = 0  # 统计括号总数
    for mem in HXS:
        if mem in '[]()【】（）':  # 检查是否是括号字符
            nem += 1

    # 检查括号是否匹配
    error = 0
    for mem in range(0, length, 1):
        if HXS[mem] in '[(【（':  # 左括号
            error += 1
        elif HXS[mem] in '])】）':  # 右括号
            error -= 1

    if error != 0:  # 括号不匹配
        raise Warning('括号错位')

    # 记录括号位置
    dic = {}
    dic['[]'] = []  # 方括号位置列表
    dic['()'] = []  # 圆括号位置列表

    for mem in range(0, length, 1):
        if HXS[mem] == '[':  # 记录左方括号位置
            dic['['] = mem
        elif HXS[mem] == ']':  # 记录右方括号位置
            last = dic['[']
            dic['[]'].append([last, mem])  # 添加方括号对
            dic['['] = None
        elif HXS[mem] == '(':  # 记录左圆括号位置
            dic['('] = mem
        elif HXS[mem] == ')':  # 记录右圆括号位置
            last = dic['(']
            dic['()'].append([last, mem])  # 添加圆括号对
            dic['('] = None

    return dic


def huanyuan(string: str, list: list):
    """
    处理括号及其系数的展开

    参数:
        string (str): 包含括号的化学式
        list (list): 括号位置对 [起始位置, 结束位置]

    返回:
        str: 展开后的化学式
    """
    a = list[0]  # 括号起始位置
    b = list[1]  # 括号结束位置
    kuohaonei = string[a + 1:b]  # 括号内的内容
    length = len(string)  # 字符串总长度

    # 提取括号后的系数
    if b == length:  # 括号在末尾
        xishu = 1
    elif b + 2 < length:  # 有两位数字系数
        if (string[b + 1] in '1234567890') and (string[b + 2] in '1234567890'):
            xishu = int(string[b + 1:b + 3])
        elif b + 1 < length:  # 有一位数字系数
            if string[b + 1] in '1234567890':
                xishu = int(string[b + 1])
            elif not string[b + 1] in '1234567890':  # 无系数
                xishu = 1
    elif b + 1 == length:  # 括号后无字符
        xishu = 1
    elif b + 2 == length:  # 括号后只有一位
        xishu = int(string[b + 1])

    # 分割字符串
    qian = string[0:a]  # 括号前部分
    hou = string[b + 1:]  # 括号后部分

    # 分析括号内化学式的组成
    zucheng, _ = ZC(kuohaonei)
    zu = ''

    # 将括号内元素的系数乘以括号外的系数
    for i in zucheng:
        zu = zu + i[0] + str(i[1] * xishu)

    # 重新组合字符串
    if xishu == 1:  # 系数为1的情况
        return qian + zu + hou
    else:  # 系数不为1的情况
        if len(str(xishu)) == 2:  # 两位系数
            return qian + zu + hou[2:]
        elif len(str(xishu)) == 1:  # 一位系数
            return qian + zu + hou[1:]


def hebinlist(list: list):
    """
    合并相同元素，计算总原子数

    参数:
        list (list): 元素列表，格式为[[元素名, 原子数], ...]

    返回:
        list: 合并后的元素列表
    """
    element = []  # 存储不重复的元素名
    number = []  # 存储元素对应的总原子数

    # 提取不重复的元素
    for i in list:
        if i[0] in element:
            continue
        else:
            element.append(i[0])

    # 计算每个元素的总原子数
    for k in element:
        num = 0
        for i in list:
            if i[0] == k:
                num = num + i[1]
            else:
                continue
        number.append([k, num])  # 添加元素及其总原子数

    return number


def hebin(list: list):
    """
    去重函数

    参数:
        list (list): 任意列表

    返回:
        list: 去重后的列表
    """
    newlist = []
    for i in list:
        if i in newlist:
            pass
        else:
            newlist.append(i)
    return newlist


def gongbei(num):
    """
    求多个数的最小公倍数

    参数:
        num (list): 数字列表

    返回:
        int: 最小公倍数
    """
    minimum = 1
    for i in num:
        # 使用公式：lcm(a,b) = a*b/gcd(a,b)
        minimum = int(i) * int(minimum) / math.gcd(int(i), int(minimum))
    return int(minimum)


def huagui(solve):
    """
    将分数系数转换为整数系数

    参数:
        solve (list): 系数列表（可能包含分数）

    返回:
        int: 所有分母的最小公倍数
    """
    allfenmu = []  # 存储所有分母
    for i in range(0, len(solve), 1):
        k = str(solve[i])  # 将系数转为字符串
        try:
            fenmu = k[k.index('/') + 1:]  # 提取分母
        except:
            fenmu = 1  # 没有分母，即为整数

        try:
            allfenmu.append(int(fenmu))  # 添加分母
        except:
            try:
                fenmu = k[k.index('/') + 1:]  # 再次尝试提取
                allfenmu.append(int(fenmu))
            except:
                f = int(fenmu[0])  # 处理特殊情况
                allfenmu.append(f)

    # 计算所有分母的最小公倍数
    all = gongbei(allfenmu)
    return all


def ZC(Hxs):
    """
    解析化学式，提取元素组成

    参数:
        Hxs (str): 化学式字符串

    返回:
        tuple: (元素组成列表, 元素名列表)
    """
    length = len(Hxs)  # 字符串长度
    capital = []  # 存储大写字母位置（元素符号起始）
    end = []  # 备用列表
    n = 0  # 数字位数计数器
    element = []  # 元素名列表
    output = []  # 输出列表，格式为[[元素名, 原子数], ...]

    # 找到所有大写字母位置（元素符号起始）
    for number in range(0, length, 1):
        if Hxs[number] in 'QWERTYUIOPASDFGHJKLZXCVBNM':
            capital.append(number)

    # 解析每个元素
    for ele in capital:
        n = 0
        if ele + 1 == length:  # 元素在末尾
            element.append(Hxs[ele])
            output.append([Hxs[ele], 1])  # 原子数为1
        elif Hxs[ele + 1] in 'QWERTYUIOPASDFGHJKLZXCVBNM':  # 下一个也是大写字母
            element.append(Hxs[ele])
            output.append([Hxs[ele], 1])  # 单个元素，原子数为1
        elif Hxs[ele + 1] in 'qwertyuiopasdfghjklzxcvbnm':  # 有小写字母（双字母元素）
            element.append(Hxs[ele:ele + 2])  # 提取两个字母
            if ele + 2 == length:  # 元素在末尾
                output.append([Hxs[ele:ele + 2], 1])
            elif Hxs[ele + 2] in 'QWERTYUIOPASDFGHJKLZXCVBNM':  # 后面是大写字母
                output.append([Hxs[ele:ele + 2], 1])
            elif ele + 2 < length:  # 后面是数字
                try:
                    # 尝试提取两位数字
                    o = int(Hxs[ele + 2:ele + 4])
                    output.append([Hxs[ele:ele + 2], o])
                except:
                    # 尝试提取一位数字
                    o = int(Hxs[ele + 2])
                    output.append([Hxs[ele:ele + 2], o])
        elif Hxs[ele + 1] in '1234567890':  # 后面是数字
            element.append(Hxs[ele])
            # 查找连续的数字
            while ele + 2 + n < length and (Hxs[ele + 2 + n] in '1234567890'):
                n += 1
            # 提取原子数
            output.append([Hxs[ele:ele + 1], int(Hxs[ele + 1: ele + 2 + n])])

    output2 = element  # 元素名列表
    return output, output2


def HXS_ZC(HXS: str):
    """
    处理带括号的化学式，展开括号

    参数:
        HXS (str): 化学式字符串

    返回:
        tuple: (展开后的元素组成列表, 元素名列表)

    异常:
        Warning: 当括号不匹配时抛出
    """
    length = len(HXS)  # 字符串长度
    nem = 0  # 括号计数器
    for mem in HXS:
        if mem in '[]()【】（）':
            nem += 1

    # 检查括号匹配
    error = 0
    for mem in range(0, length, 1):
        if HXS[mem] in '[(【（':
            error += 1
        elif HXS[mem] in '])】）':
            error -= 1

    if error != 0:
        raise Warning('括号错位')

    # 分析括号位置
    dic = {}
    dic['[]'] = []
    dic['()'] = []

    for mem in range(0, length, 1):
        if HXS[mem] == '[':
            dic['['] = mem
        elif HXS[mem] == ']':
            last = dic['[']
            dic['[]'].append([last, mem])
            dic['['] = None
        elif HXS[mem] == '(':
            dic['('] = mem
        elif HXS[mem] == ')':
            last = dic['(']
            dic['()'].append([last, mem])
            dic['('] = None

    print(dic)  # 调试信息

    # 先处理圆括号，再处理方括号
    small = dic['()']  # 圆括号
    middle = dic['[]']  # 方括号

    # 展开所有圆括号
    while len(dic['()']) != 0:
        A = dic['()']
        HXS = huanyuan(HXS, A[0])  # 展开第一个圆括号
        dic = fangfa(HXS)  # 重新分析括号

    # 展开所有方括号
    while len(dic['[]']) != 0:
        A = dic['[]']
        HXS = huanyuan(HXS, A[0])  # 展开第一个方括号
        dic = fangfa(HXS)  # 重新分析括号

    print(HXS)  # 调试信息

    # 解析展开后的化学式
    liout, alete = ZC(HXS)
    return liout, alete


def Func(yueshu, leng, newlist, beginnum, endnum, ert, allelement1):
    """
    构建并求解方程组

    参数:
        yueshu: 约束条件（最小公倍数）
        leng: 元素种类数
        newlist: 元素名列表
        beginnum: 反应物数量
        endnum: 生成物数量
        ert: 系数符号列表
        allelement1: 所有物质的元素组成字典列表

    返回:
        list: 解得的系数列表
    """
    if yueshu is None:
        yueshu = 1

    # 获取符号对象列表
    symbols = [symbols_dict[s] for s in ert[:beginnum + endnum]]

    equations = []  # 存储所有方程

    # 构建每个元素的原子守恒方程
    for i in range(leng):
        equation = 0
        element_name = newlist[i]

        # 对于每个物质，计算其对该元素原子数的贡献
        for t in range(beginnum + endnum):
            # 获取该物质中该元素的原子数，如果不存在则为0
            atom_count = allelement1[t].get(element_name, 0)
            equation += symbols[t] * atom_count

        # 添加到方程列表
        equations.append(sp.Eq(equation, 0))

    # 添加约束方程（使第一个系数为指定值）
    equations.append(sp.Eq(symbols[0], yueshu))

    # 求解方程组
    try:
        solution = sp.solve(equations, symbols)
    except Exception as e:
        # 如果求解失败，返回空列表
        print(f"求解方程时出错: {e}")
        return []

    # 按ert列表的顺序提取解
    atlast = []
    for symbol in symbols:
        if symbol in solution:
            atlast.append(solution[symbol])
        else:
            atlast.append(0)  # 如果没有解，设为0

    return atlast


def run(stringwhat):
    """
    主配平函数

    参数:
        stringwhat (str): 输入的化学方程式字符串（格式：反应物1+反应物2=生成物1+生成物2）

    返回:
        str: 配平后的化学方程式
    """
    fangchengshi = stringwhat  # 化学方程式
    q = fangchengshi.split('=')  # 按等号分割

    try:
        q1 = q[0]  # 反应物部分
        q2 = q[1]  # 生成物部分
        l1 = q1.split('+')  # 分割反应物
        l2 = q2.split('+')  # 分割生成物
        beginnum = len(l1)  # 反应物数量
        endnum = len(l2)  # 生成物数量
    except IndexError:
        return 'IndexError:请确保你输入了能配平的玩意'

    # 提取所有元素
    list = []
    for i in l1:
        list.extend(HXS_ZC(i)[1])  # 添加反应物元素
    newlist = hebin(list)  # 去重
    leng = len(newlist)  # 元素种类数

    # 分析每个物质的元素组成
    allelements = []
    allelement1 = []  # 反应物元素组成
    allelement2 = []  # 生成物元素组成

    for first in l1:
        allelements = HXS_ZC(first)[0]
        # 转换为字典格式：{元素名: 原子数}
        allelement1.append(dict(hebinlist(allelements)))

    for second in l2:
        allelements = HXS_ZC(second)[0]
        # 转换为字典格式：{元素名: 原子数}
        allelement2.append(dict(hebinlist(allelements)))

    allelement1.extend(allelement2)  # 合并反应物和生成物

    # 第一次求解（可能得到分数解）
    atlast = Func(yueshu=None, leng=leng, newlist=newlist, beginnum=beginnum, endnum=endnum, ert=ert,
                  allelement1=allelement1)

    # 将分数系数转换为整数
    yueshu = huagui(atlast)

    # 第二次求解（得到整数解）
    atlast = Func(yueshu=yueshu, leng=leng, newlist=newlist, beginnum=beginnum, endnum=endnum, ert=ert,
                  allelement1=allelement1)

    # 构建配平后的方程式字符串
    fanyinwu = ''  # 反应物部分
    shengchenwu = ''  # 生成物部分

    # 构建反应物部分
    for ij in range(0, beginnum, 1):
        fanyinwu = fanyinwu + '+ (' + str(atlast[ij]) + ') ' + l1[ij]
    fanyinwu = fanyinwu[1:]  # 去掉开头的+

    # 构建生成物部分
    for ij in range(beginnum, beginnum + endnum, 1):
        try:
            shengchenwu = shengchenwu + '+ (' + str(-atlast[ij]) + ') ' + l2[ij - beginnum]
        except:
            shengchenwu = shengchenwu + '+ ( -' + atlast[ij] + ') ' + l2[ij - beginnum]
    shengchenwu = shengchenwu[1:]  # 去掉开头的+

    return fanyinwu + ' = ' + shengchenwu


class QTextEditDemo(QWidget):
    """
    主GUI类，用于显示化学方程式配平界面
    """

    def __init__(self):
        super(QTextEditDemo, self).__init__()
        self.initUI()  # 初始化界面

    def initUI(self):
        """
        初始化用户界面
        """
        self.setWindowTitle("CBalance配平方程式")  # 窗口标题
        self.resize(800, 140)  # 窗口大小

        # 创建文本编辑框
        self.textEdit = QTextEdit()
        self.textEdit.setFontFamily('微软雅黑')  # 设置字体
        self.textEdit.setFontPointSize(16)  # 设置字号

        # 创建按钮
        self.buttonToText = QPushButton("配平")  # 配平按钮
        self.buttonToHTML = QPushButton("清空")  # 清空按钮

        # 创建布局
        layout = QVBoxLayout()  # 垂直布局
        layout1 = QHBoxLayout()  # 水平布局（用于按钮）

        # 将按钮添加到水平布局
        layout1.addWidget(self.buttonToText)
        layout1.addWidget(self.buttonToHTML)

        # 将文本编辑框和按钮布局添加到垂直布局
        layout.addWidget(self.textEdit)
        layout.addLayout(layout1)

        self.setLayout(layout)  # 设置窗口布局

        # 连接按钮点击事件到相应的函数
        self.buttonToText.clicked.connect(self.onClick_ButtonToText)
        self.buttonToHTML.clicked.connect(self.onClick_ButtonToHTML)

    def onClick_ButtonToText(self):
        """
        配平按钮点击事件处理函数
        """
        if len(self.textEdit.toPlainText()) == 0:  # 检查是否输入了方程式
            self.textEdit.setFontPointSize(16)
            self.textEdit.setText('Error:无方程式')  # 显示错误信息
            self.textEdit.setFontFamily('微软雅黑')
        else:
            # 获取输入的方程式并进行配平
            try:
                a = run(self.textEdit.toPlainText())
                self.textEdit.setFontPointSize(16)
                self.textEdit.setText(a)  # 显示配平结果
                self.textEdit.setFontFamily('微软雅黑')
            except Exception as e:
                self.textEdit.setFontPointSize(16)
                self.textEdit.setText(f'Error: {str(e)}')  # 显示错误信息
                self.textEdit.setFontFamily('微软雅黑')

    def onClick_ButtonToHTML(self):
        """
        清空按钮点击事件处理函数
        """
        self.textEdit.setPlainText("")  # 清空文本编辑框
        self.textEdit.setFontFamily('微软雅黑')
        self.textEdit.setFontPointSize(16)


if __name__ == '__main__':
    """
    程序入口点
    """
    app = QApplication(sys.argv)  # 创建QApplication实例
    main = QTextEditDemo()  # 创建主窗口实例
    main.show()  # 显示主窗口
    sys.exit(app.exec_())  # 进入事件循环